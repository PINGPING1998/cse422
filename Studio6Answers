1} Tara Renduchintala

2}
sing: sings the song Bilbo sings when setting off on his adventure
    in The Fellowship of the Ring for the inputted number of verses
dense_mm: creates and multiplies 2 NxN matrices where N is the inputted
    number      
parallel_dense_mm: creates and multiplies 2 NxN matrices where N is the inputted
    number   
sort: generates an array and sorts it

3}
time ./sing 1:
real 0m0.008s
user 0m0.000s
sys  0m0.002s

time ./sing 4:
real 0m0.049s
user 0m0.000s
sys  0m0.003s

time ./sort 4:
real 0m0.005s
user 0m0.001s
sys  0m0.000s

time ./sort 8:
real 0m0.010s
user 0m0.001s
sys  0m0.001s

time ./dense_mm 1:
real 0m0.005s
user 0m0.001s
sys  0m0.001s

time ./dense_mm 4:
real 0m0.006s
user 0m0.000s
sys  0m0.002s

time ./parallel_dense_mm 1:
real 0m0.024s
user 0m0.194s
sys  0m0.002s

time ./parallel_dense_mm 4:
real 0m0.032s
user 0m0.205s
sys  0m0.001s

4} 
Real: the amount of actual time (according to the wall clock) 
    spent on the process
User: the amount of time the process spent in User space
Sys: the amount of time the process spend in Kernel space

5}
time ./dense_mm 1000:
real 0m4.970s
user 0m4.954s
sys  0m0.014s

time ./parallel_dense_mm 1000:
real 0m0.447s
user 0m12.052s
sys  0m0.016s

From using the time command, it is evident that the real time
spent doing the non-parallel computaion is greater than when
parallel computation is being used. However, the time in userspace
is greater for parallel computing than it is for non-parallel computation.
The reason that the user time is greater is because the parallel program
is running mulitple threads at the same time and the user time
is the addition of all of the time spent in User space by those 
multiple threads.

6}
./sing 1000:
real 0m0.144s
user 0m0.005s
sys  0m0.031s

The user timing was significantly smaller than the sys timing.
This means that the process spent a lot more time in the kernel 
space than in user space. However, real time was a lot larger than
both user and sys time. 

In ./dense_mm the sys time was significantly lower than the user space
and that is most likely because there is no real computation 
done in user space in ./sing while there is a significant amount
done in ./dense_mm.

7}
Not a good clock: Clock_Realtime

Clock Realtime would not be a good clock as it measures real 
(wall-clock) time. This won't give a proper understanding of
user space time.

Good clock: Clock_Process_CPUtime_ID
This clock measures the CPU time on all threads in the process.
This will give an accurate measurement on how long the process
spent computing different things. 

8}
[trenduchintala@linuxlab003 test_programs]$ ./getres 1
resolution for realtime clock :          0.000000001

resolution for coarse realtime clock:          0.001000000

The resolution for my coarse realtime clock was far larger than the resolution for
the normal realtime clock. This means that the realtime clock is way more precise than
the coarse realtime clock.

9} ANSWER THIS

10} The time it took to run get_time(REALTIMECLOCK, ...) was .000000318 seconds. I
was able to obtain this by getting the REALTIME CLOCK value at the start. Then, I ran a 
get_time(CLOCK) dummy function. And at the end, I captured the clock time again and
compared the two times. 


11} 
[trenduchintala@linuxlab004 test_programs]$ ./timed_parallel_dense_mm 100 100
Generating matrices...
Multiplying matrices...
Multiplication done!
Average Time for Parallel Process: 6071917
Minimum Time: 10000
Maximum Time: 11568770

I think a common case running time would be somewhere in between 200,000 to 300,000 nanoseconds.
I think it would be lower than what is shown above because we are running multiplication
in parallel on 100x100 matrices. In most cases, I believe the dimensions should be lower
in which case, I would err on the lowerbound of the timing we have recieved here. However,
I think the lowest bound would be 10,000. Therefore, the timing woud be about 20x that in 
most cases.

12}

[27073.359668] ktime module initialized
[27087.702794] ktime  module is being unloaded
[27087.702815] Number of seconds: 1  and Number of Nanoseconds: 1458067196

I used the ktime_get_real() function because I wanted to see based on 
clock time how long it was between initialization and unloading. I
was curious to see how it would be in terms of nanoseconds. Also among
the options given, it seemed the most intutitive as get_raw is not 
really used in the kernel. 



